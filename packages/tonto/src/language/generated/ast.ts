/******************************************************************************
 * This file was generated by langium-cli 3.0.1.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const TontoTerminals = {
    WS: /\s+/,
    INT: /[0-9]+/,
    STRING: /"[^"]*"|'[^']*'/,
    CAMEL_CASE_ID: /[a-z]([a-zA-Z0-9_]*)/,
    CAPITALIZED_ID: /[A-Z]([a-zA-Z0-9_]*)/,
    ID: /[_a-zA-Z][\w_]*/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AuxiliaryDeclaration = DataType | ElementRelation | GeneralizationSet;

export const AuxiliaryDeclaration = 'AuxiliaryDeclaration';

export function isAuxiliaryDeclaration(item: unknown): item is AuxiliaryDeclaration {
    return reflection.isInstance(item, AuxiliaryDeclaration);
}

export type ClassDeclarationOrRelation = ClassDeclaration | ElementRelation;

export const ClassDeclarationOrRelation = 'ClassDeclarationOrRelation';

export function isClassDeclarationOrRelation(item: unknown): item is ClassDeclarationOrRelation {
    return reflection.isInstance(item, ClassDeclarationOrRelation);
}

export type DataTypeOrClass = ClassDeclaration | DataType;

export const DataTypeOrClass = 'DataTypeOrClass';

export function isDataTypeOrClass(item: unknown): item is DataTypeOrClass {
    return reflection.isInstance(item, DataTypeOrClass);
}

export type DataTypeOrClassOrRelation = ClassDeclaration | DataType | ElementRelation;

export const DataTypeOrClassOrRelation = 'DataTypeOrClassOrRelation';

export function isDataTypeOrClassOrRelation(item: unknown): item is DataTypeOrClassOrRelation {
    return reflection.isInstance(item, DataTypeOrClassOrRelation);
}

export type Declaration = AuxiliaryDeclaration | ClassDeclaration;

export const Declaration = 'Declaration';

export function isDeclaration(item: unknown): item is Declaration {
    return reflection.isInstance(item, Declaration);
}

export type EndurantType = NonSortal | Sortal | UltimateSortal;

export function isEndurantType(item: unknown): item is EndurantType {
    return isNonSortal(item) || isUltimateSortal(item) || isSortal(item);
}

export type NAME = string;

export function isNAME(item: unknown): item is NAME {
    return (typeof item === 'string' && (/[_a-zA-Z][\w_]*/.test(item) || /"[^"]*"|'[^']*'/.test(item) || /[a-z]([a-zA-Z0-9_]*)/.test(item) || /[A-Z]([a-zA-Z0-9_]*)/.test(item)));
}

export type NonEndurantType = 'event' | 'process' | 'situation';

export function isNonEndurantType(item: unknown): item is NonEndurantType {
    return item === 'event' || item === 'situation' || item === 'process';
}

export type NonSortal = 'category' | 'historicalRoleMixin' | 'mixin' | 'phaseMixin' | 'roleMixin';

export function isNonSortal(item: unknown): item is NonSortal {
    return item === 'category' || item === 'mixin' || item === 'phaseMixin' || item === 'roleMixin' || item === 'historicalRoleMixin';
}

export type OntologicalNature = 'abstract-individuals' | 'collectives' | 'events' | 'extrinsic-modes' | 'functional-complexes' | 'intrinsic-modes' | 'objects' | 'qualities' | 'quantities' | 'relators' | 'situations' | 'types';

export function isOntologicalNature(item: unknown): item is OntologicalNature {
    return item === 'objects' || item === 'functional-complexes' || item === 'collectives' || item === 'quantities' || item === 'relators' || item === 'intrinsic-modes' || item === 'extrinsic-modes' || item === 'qualities' || item === 'events' || item === 'situations' || item === 'types' || item === 'abstract-individuals';
}

export type QualifiedName = string;

export function isQualifiedName(item: unknown): item is QualifiedName {
    return typeof item === 'string';
}

export type RelationStereotype = 'aggregation' | 'bringsAbout' | 'characterization' | 'comparative' | 'componentOf' | 'composition' | 'constitution' | 'creation' | 'derivation' | 'externalDependence' | 'formal' | 'historicalDependence' | 'inherence' | 'instantiation' | 'manifestation' | 'material' | 'mediation' | 'memberOf' | 'participation' | 'participational' | 'subCollectionOf' | 'subQuantityOf' | 'termination' | 'triggers' | 'value' | string;

export function isRelationStereotype(item: unknown): item is RelationStereotype {
    return item === 'material' || item === 'derivation' || item === 'comparative' || item === 'mediation' || item === 'characterization' || item === 'externalDependence' || item === 'componentOf' || item === 'memberOf' || item === 'subCollectionOf' || item === 'subQuantityOf' || item === 'instantiation' || item === 'termination' || item === 'participational' || item === 'participation' || item === 'historicalDependence' || item === 'creation' || item === 'manifestation' || item === 'bringsAbout' || item === 'triggers' || item === 'composition' || item === 'aggregation' || item === 'inherence' || item === 'value' || item === 'formal' || item === 'manifestation' || item === 'constitution' || (typeof item === 'string' && (/[_a-zA-Z][\w_]*/.test(item) || /"[^"]*"|'[^']*'/.test(item)));
}

export type Sortal = 'historicalRole' | 'phase' | 'role' | 'subkind';

export function isSortal(item: unknown): item is Sortal {
    return item === 'subkind' || item === 'phase' || item === 'role' || item === 'historicalRole';
}

export type UltimateSortal = 'collective' | 'extrinsicMode' | 'intrinsicMode' | 'kind' | 'mode' | 'powertype' | 'quality' | 'quantity' | 'relator' | 'type';

export function isUltimateSortal(item: unknown): item is UltimateSortal {
    return item === 'kind' || item === 'collective' || item === 'quantity' || item === 'quality' || item === 'mode' || item === 'intrinsicMode' || item === 'extrinsicMode' || item === 'relator' || item === 'type' || item === 'powertype';
}

export type UnspecifiedType = 'class';

export function isUnspecifiedType(item: unknown): item is UnspecifiedType {
    return item === 'class';
}

export interface Attribute extends AstNode {
    readonly $container: ClassDeclaration | DataType;
    readonly $type: 'Attribute';
    attributeTypeRef: Reference<DataType>;
    cardinality?: Cardinality;
    isConst: boolean;
    isDerived: boolean;
    isOrdered: boolean;
    name: QualifiedName;
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface Cardinality extends AstNode {
    readonly $container: Attribute | ElementRelation;
    readonly $type: 'Cardinality';
    lowerBound: '*' | number;
    upperBound?: '*' | number;
}

export const Cardinality = 'Cardinality';

export function isCardinality(item: unknown): item is Cardinality {
    return reflection.isInstance(item, Cardinality);
}

export interface ClassDeclaration extends AstNode {
    readonly $container: ContextModule;
    readonly $type: 'ClassDeclaration';
    attributes: Array<Attribute>;
    classElementType: OntologicalCategory;
    instanceOf?: Reference<ClassDeclaration>;
    name: string;
    ontologicalNatures?: ElementOntologicalNature;
    references: Array<ElementRelation>;
    specializationEndurants: Array<Reference<ClassDeclaration>>;
}

export const ClassDeclaration = 'ClassDeclaration';

export function isClassDeclaration(item: unknown): item is ClassDeclaration {
    return reflection.isInstance(item, ClassDeclaration);
}

export interface ContextModule extends AstNode {
    readonly $container: Model;
    readonly $type: 'ContextModule';
    declarations: Array<Declaration>;
    isGlobal: boolean;
    name: QualifiedName;
}

export const ContextModule = 'ContextModule';

export function isContextModule(item: unknown): item is ContextModule {
    return reflection.isInstance(item, ContextModule);
}

export interface DataType extends AstNode {
    readonly $container: ContextModule;
    readonly $type: 'DataType';
    attributes: Array<Attribute>;
    elements: Array<EnumElement>;
    isEnum: boolean;
    name: QualifiedName;
    ontologicalCategory?: 'datatype';
    ontologicalNature?: ElementOntologicalNature;
    specializationEndurants: Array<Reference<DataTypeOrClass>>;
}

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export interface ElementOntologicalNature extends AstNode {
    readonly $container: ClassDeclaration | DataType;
    readonly $type: 'ElementOntologicalNature';
    natures: Array<OntologicalNature>;
}

export const ElementOntologicalNature = 'ElementOntologicalNature';

export function isElementOntologicalNature(item: unknown): item is ElementOntologicalNature {
    return reflection.isInstance(item, ElementOntologicalNature);
}

export interface ElementRelation extends AstNode {
    readonly $container: ClassDeclaration | ContextModule;
    readonly $type: 'ElementRelation';
    firstCardinality?: Cardinality;
    firstEnd?: Reference<DataTypeOrClassOrRelation>;
    firstEndMetaAttributes?: RelationMetaAttributes;
    hasInverse?: 'inverseOf';
    inverseEnd?: Reference<ElementRelation>;
    isAggregation: boolean;
    isAggregationInverted: boolean;
    isAssociation: boolean;
    isComposition: boolean;
    isCompositionInverted: boolean;
    name?: string;
    relationType?: RelationStereotype;
    secondCardinality?: Cardinality;
    secondEnd: Reference<DataTypeOrClassOrRelation>;
    secondEndMetaAttributes?: RelationMetaAttributes;
    specializeRelation?: Reference<ElementRelation>;
}

export const ElementRelation = 'ElementRelation';

export function isElementRelation(item: unknown): item is ElementRelation {
    return reflection.isInstance(item, ElementRelation);
}

export interface EnumElement extends AstNode {
    readonly $container: DataType;
    readonly $type: 'EnumElement';
    name: string;
}

export const EnumElement = 'EnumElement';

export function isEnumElement(item: unknown): item is EnumElement {
    return reflection.isInstance(item, EnumElement);
}

export interface GeneralizationSet extends AstNode {
    readonly $container: ContextModule;
    readonly $type: 'GeneralizationSet';
    categorizerItems: Array<Reference<ClassDeclarationOrRelation>>;
    complete: boolean;
    disjoint: boolean;
    generalItem: Reference<ClassDeclarationOrRelation>;
    name: string;
    specificItems: Array<Reference<ClassDeclarationOrRelation>>;
}

export const GeneralizationSet = 'GeneralizationSet';

export function isGeneralizationSet(item: unknown): item is GeneralizationSet {
    return reflection.isInstance(item, GeneralizationSet);
}

export interface Import extends AstNode {
    readonly $container: Model;
    readonly $type: 'Import';
    packageAlias?: string;
    referencedModel: Reference<ContextModule>;
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface Model extends AstNode {
    readonly $type: 'Model';
    imports: Array<Import>;
    module: ContextModule;
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface OntologicalCategory extends AstNode {
    readonly $container: ClassDeclaration;
    readonly $type: 'OntologicalCategory';
    ontologicalCategory: EndurantType | NonEndurantType | UnspecifiedType;
}

export const OntologicalCategory = 'OntologicalCategory';

export function isOntologicalCategory(item: unknown): item is OntologicalCategory {
    return reflection.isInstance(item, OntologicalCategory);
}

export interface RelationMetaAttribute extends AstNode {
    readonly $container: RelationMetaAttributes;
    readonly $type: 'RelationMetaAttribute';
    isConst: boolean;
    isDerived: boolean;
    isOrdered: boolean;
    redefinesRelation?: Reference<ElementRelation>;
    subsetRelation?: Reference<ElementRelation>;
}

export const RelationMetaAttribute = 'RelationMetaAttribute';

export function isRelationMetaAttribute(item: unknown): item is RelationMetaAttribute {
    return reflection.isInstance(item, RelationMetaAttribute);
}

export interface RelationMetaAttributes extends AstNode {
    readonly $container: ElementRelation;
    readonly $type: 'RelationMetaAttributes';
    endMetaAttributes: Array<RelationMetaAttribute>;
    endName?: string;
}

export const RelationMetaAttributes = 'RelationMetaAttributes';

export function isRelationMetaAttributes(item: unknown): item is RelationMetaAttributes {
    return reflection.isInstance(item, RelationMetaAttributes);
}

export type TontoAstType = {
    Attribute: Attribute
    AuxiliaryDeclaration: AuxiliaryDeclaration
    Cardinality: Cardinality
    ClassDeclaration: ClassDeclaration
    ClassDeclarationOrRelation: ClassDeclarationOrRelation
    ContextModule: ContextModule
    DataType: DataType
    DataTypeOrClass: DataTypeOrClass
    DataTypeOrClassOrRelation: DataTypeOrClassOrRelation
    Declaration: Declaration
    ElementOntologicalNature: ElementOntologicalNature
    ElementRelation: ElementRelation
    EnumElement: EnumElement
    GeneralizationSet: GeneralizationSet
    Import: Import
    Model: Model
    OntologicalCategory: OntologicalCategory
    RelationMetaAttribute: RelationMetaAttribute
    RelationMetaAttributes: RelationMetaAttributes
}

export class TontoAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Attribute', 'AuxiliaryDeclaration', 'Cardinality', 'ClassDeclaration', 'ClassDeclarationOrRelation', 'ContextModule', 'DataType', 'DataTypeOrClass', 'DataTypeOrClassOrRelation', 'Declaration', 'ElementOntologicalNature', 'ElementRelation', 'EnumElement', 'GeneralizationSet', 'Import', 'Model', 'OntologicalCategory', 'RelationMetaAttribute', 'RelationMetaAttributes'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AuxiliaryDeclaration: {
                return this.isSubtype(Declaration, supertype);
            }
            case ClassDeclaration: {
                return this.isSubtype(ClassDeclarationOrRelation, supertype) || this.isSubtype(DataTypeOrClass, supertype) || this.isSubtype(DataTypeOrClassOrRelation, supertype) || this.isSubtype(Declaration, supertype);
            }
            case DataType: {
                return this.isSubtype(AuxiliaryDeclaration, supertype) || this.isSubtype(DataTypeOrClass, supertype) || this.isSubtype(DataTypeOrClassOrRelation, supertype);
            }
            case ElementRelation: {
                return this.isSubtype(AuxiliaryDeclaration, supertype) || this.isSubtype(ClassDeclarationOrRelation, supertype) || this.isSubtype(DataTypeOrClassOrRelation, supertype);
            }
            case GeneralizationSet: {
                return this.isSubtype(AuxiliaryDeclaration, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Attribute:attributeTypeRef': {
                return DataType;
            }
            case 'ClassDeclaration:instanceOf':
            case 'ClassDeclaration:specializationEndurants': {
                return ClassDeclaration;
            }
            case 'DataType:specializationEndurants': {
                return DataTypeOrClass;
            }
            case 'ElementRelation:firstEnd':
            case 'ElementRelation:secondEnd': {
                return DataTypeOrClassOrRelation;
            }
            case 'ElementRelation:inverseEnd':
            case 'ElementRelation:specializeRelation':
            case 'RelationMetaAttribute:redefinesRelation':
            case 'RelationMetaAttribute:subsetRelation': {
                return ElementRelation;
            }
            case 'GeneralizationSet:categorizerItems':
            case 'GeneralizationSet:generalItem':
            case 'GeneralizationSet:specificItems': {
                return ClassDeclarationOrRelation;
            }
            case 'Import:referencedModel': {
                return ContextModule;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Attribute': {
                return {
                    name: 'Attribute',
                    properties: [
                        { name: 'attributeTypeRef' },
                        { name: 'cardinality' },
                        { name: 'isConst', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isOrdered', defaultValue: false },
                        { name: 'name' }
                    ]
                };
            }
            case 'Cardinality': {
                return {
                    name: 'Cardinality',
                    properties: [
                        { name: 'lowerBound' },
                        { name: 'upperBound' }
                    ]
                };
            }
            case 'ClassDeclaration': {
                return {
                    name: 'ClassDeclaration',
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'classElementType' },
                        { name: 'instanceOf' },
                        { name: 'name' },
                        { name: 'ontologicalNatures' },
                        { name: 'references', defaultValue: [] },
                        { name: 'specializationEndurants', defaultValue: [] }
                    ]
                };
            }
            case 'ContextModule': {
                return {
                    name: 'ContextModule',
                    properties: [
                        { name: 'declarations', defaultValue: [] },
                        { name: 'isGlobal', defaultValue: false },
                        { name: 'name' }
                    ]
                };
            }
            case 'DataType': {
                return {
                    name: 'DataType',
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'isEnum', defaultValue: false },
                        { name: 'name' },
                        { name: 'ontologicalCategory' },
                        { name: 'ontologicalNature' },
                        { name: 'specializationEndurants', defaultValue: [] }
                    ]
                };
            }
            case 'ElementOntologicalNature': {
                return {
                    name: 'ElementOntologicalNature',
                    properties: [
                        { name: 'natures', defaultValue: [] }
                    ]
                };
            }
            case 'ElementRelation': {
                return {
                    name: 'ElementRelation',
                    properties: [
                        { name: 'firstCardinality' },
                        { name: 'firstEnd' },
                        { name: 'firstEndMetaAttributes' },
                        { name: 'hasInverse' },
                        { name: 'inverseEnd' },
                        { name: 'isAggregation', defaultValue: false },
                        { name: 'isAggregationInverted', defaultValue: false },
                        { name: 'isAssociation', defaultValue: false },
                        { name: 'isComposition', defaultValue: false },
                        { name: 'isCompositionInverted', defaultValue: false },
                        { name: 'name' },
                        { name: 'relationType' },
                        { name: 'secondCardinality' },
                        { name: 'secondEnd' },
                        { name: 'secondEndMetaAttributes' },
                        { name: 'specializeRelation' }
                    ]
                };
            }
            case 'EnumElement': {
                return {
                    name: 'EnumElement',
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case 'GeneralizationSet': {
                return {
                    name: 'GeneralizationSet',
                    properties: [
                        { name: 'categorizerItems', defaultValue: [] },
                        { name: 'complete', defaultValue: false },
                        { name: 'disjoint', defaultValue: false },
                        { name: 'generalItem' },
                        { name: 'name' },
                        { name: 'specificItems', defaultValue: [] }
                    ]
                };
            }
            case 'Import': {
                return {
                    name: 'Import',
                    properties: [
                        { name: 'packageAlias' },
                        { name: 'referencedModel' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    properties: [
                        { name: 'imports', defaultValue: [] },
                        { name: 'module' }
                    ]
                };
            }
            case 'OntologicalCategory': {
                return {
                    name: 'OntologicalCategory',
                    properties: [
                        { name: 'ontologicalCategory' }
                    ]
                };
            }
            case 'RelationMetaAttribute': {
                return {
                    name: 'RelationMetaAttribute',
                    properties: [
                        { name: 'isConst', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isOrdered', defaultValue: false },
                        { name: 'redefinesRelation' },
                        { name: 'subsetRelation' }
                    ]
                };
            }
            case 'RelationMetaAttributes': {
                return {
                    name: 'RelationMetaAttributes',
                    properties: [
                        { name: 'endMetaAttributes', defaultValue: [] },
                        { name: 'endName' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new TontoAstReflection();
